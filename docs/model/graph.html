<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>hdlib.model.graph API documentation</title>
<meta name="description" content="Directed and undirected, weighted and unweighted graphs with hdlib">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hdlib.model.graph</code></h1>
</header>
<section id="section-intro">
<p>Directed and undirected, weighted and unweighted graphs with hdlib.</p>
<p>It implements the <strong>hdlib.model.graph.GraphModel</strong> class object which allows to represent weighted directed and undirected graphs
built according to the Hyperdimensional Computing (HDC) paradigm as described in <em>Poduval et al. 2022</em> <a href="https://doi.org/10.3389/fnins.2022.757125.">https://doi.org/10.3389/fnins.2022.757125.</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hdlib.model.graph.GraphModel"><code class="flex name class">
<span>class <span class="ident">GraphModel</span></span>
<span>(</span><span>size: int = 10000, directed: bool = False, seed: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Hyperdimensional GraphModel representation.</p>
<p>Initialize a GraphModel object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, default <code>10000</code></dt>
<dd>The size of vectors used to create a Space and define Vector objects.</dd>
<dt><strong><code>directed</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Directed or undirected.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random seed for reproducibility of results.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the vector size is not an integer number.</dd>
<dt><code>ValueError</code></dt>
<dd>If the vector size is lower than 1,000.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hdlib.model import GraphModel
&gt;&gt;&gt; graph = GraphModel(size=10000, vtype='bipolar', directed=False)
&gt;&gt;&gt; type(graph)
&lt;class 'hdlib.model.GraphModel'&gt;
</code></pre>
<p>This creates a new undirected GraphModel object around a Space that can host random bipolar Vector objects with size 10,000.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphModel(object):
    &#34;&#34;&#34;Hyperdimensional GraphModel representation.&#34;&#34;&#34;

    def __init__(
        self,
        size: int=10000,
        directed: bool=False,
        seed: Optional[int]=None
    ) -&gt; &#34;GraphModel&#34;:
        &#34;&#34;&#34;Initialize a GraphModel object.

        Parameters
        ----------
        size : int, default 10000
            The size of vectors used to create a Space and define Vector objects.
        directed : bool, default False
            Directed or undirected.
        seed : int, optional
            Random seed for reproducibility of results.

        Raises
        ------
        TypeError
            If the vector size is not an integer number.
        ValueError
            If the vector size is lower than 1,000.

        Examples
        --------
        &gt;&gt;&gt; from hdlib.model import GraphModel
        &gt;&gt;&gt; graph = GraphModel(size=10000, vtype=&#39;bipolar&#39;, directed=False)
        &gt;&gt;&gt; type(graph)
        &lt;class &#39;hdlib.model.GraphModel&#39;&gt;

        This creates a new undirected GraphModel object around a Space that can host random bipolar Vector objects with size 10,000.
        &#34;&#34;&#34;

        if not isinstance(size, int):
            raise TypeError(&#34;Vectors size must be an integer number&#34;)

        if size &lt; 1000:
            raise ValueError(&#34;Vectors size must be greater than or equal to 1000&#34;)

        # Register vectors dimensionality
        self.size = size

        # Register a set with edge weights (classes)
        self.weights = set()

        # Register vectors type
        self.vtype = &#34;bipolar&#34;

        # Register whether the graph is directed or undirected
        self.directed = directed

        # Keep track of the number of nodes
        self.nodes_counter = 0

        # Keep track of the number of edges
        self.edges_counter = 0

        # Hyperdimensional space
        self.space = Space(size=self.size, vtype=self.vtype)

        self.seed = seed

        if self.seed is None:
            self.rand = np.random.default_rng()

        else:
            # Conditions on random seed for reproducibility
            # numpy allows integers as random seeds
            if not isinstance(seed, int):
                raise TypeError(&#34;Seed must be an integer number&#34;)

            self.rand = np.random.default_rng(seed=self.seed)

        # We estimate a proper threshold to establish whether an edge exists between two nodes
        # Keep track of these thresholds to avoid recomputing them
        # This is also weight dependant
        self.weight_to_node_specific_thresholds = dict()

        # Also keep track of the edges for error rate estimation and error mitigation
        self.edges = set()

        # Keep track of hdlib version
        self.version = __version__

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Print the GraphModel object properties.

        Returns
        -------
        str
            A description of the GraphModel object. It reports the vectors size, the vector type,
            the number of nodes, the number of edges, and whether it is directed or undirected.

        Examples
        --------
        &gt;&gt;&gt; from hdlib.model import GraphModel
        &gt;&gt;&gt; graph = GraphModel()
        &gt;&gt;&gt; print(graph)

                Class:    hdlib.model.graph.GraphModel
                Version:  0.1.17
                Size:     10000
                Type:     bipolar
                Directed: False
                Weights:  100
                Nodes:    0
                Edges:    0
                Seed:     None

        Print the GraphModel object properties. By default, the size of vectors in space is 10,000,
        their types is bipolar, and the number of level vectors is 2. The number of data points 
        and the number of class labels are empty here since no dataset has been processed yet.
        &#34;&#34;&#34;

        return &#34;&#34;&#34;
            Class:    hdlib.model.graph.GraphModel
            Version:  {}
            Size:     {}
            Type:     {}
            Directed: {}
            Weights:  {}
            Nodes:    {}
            Edges:    {}
            Seed:     {}
        &#34;&#34;&#34;.format(
            self.version,
            self.size,
            self.vtype,
            self.directed,
            len(self.weights),
            self.nodes_counter,
            self.edges_counter,
            self.seed
        )

    def _add_edge(
        self,
        node1: str,
        node2: str,
        weight: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Add an edge to the graph and automatically build nodes if they do not exist in the space.

        Parameters
        ----------
        node1 : str
            Node name.
        node2 : str
            Node name.
        weight : Any
            The edge weight.
            This can be numeric or a string used as a class label.

        Raises
        ------
        ValueError
            If `node1` or `node2` is equals to `GRAPH_ID`.
        &#34;&#34;&#34;

        if node1 == GRAPH_ID or node2 == GRAPH_ID:
            raise ValueError(f&#34;Node names cannot match with the private graph ID `{GRAPH_ID}`&#34;)

        edge_exists = False

        if node1 in self.space.space and node2 in self.space.space:
            # Check whether an edge between node1 and node2 already exists
            if self.directed and node2 in self.space.space[node1].children:
                edge_exists = True

            elif not self.directed and node2 in self.space.space[node1].children and node1 in self.space.space[node2].children:
                edge_exists = True

        if not edge_exists:
            for node in [node1, node2]:
                # Build node if it is not in the space
                if node not in self.space.space:
                    # Build a random binary vector
                    vector = Vector(
                        name=node,
                        size=self.size,
                        vtype=self.vtype
                    )

                    # Define a new property called memory to store information
                    # about current node neighbors
                    setattr(vector, &#34;memory&#34;, None)

                    # Define a new property called weights to store
                    # edge weights in case of a weighted graph
                    setattr(vector, &#34;weights&#34;, dict())

                    # Register the node into the space
                    self.space.insert(vector)

                    # Increment the nodes counter
                    self.nodes_counter += 1

            # Take track of the edge as a link between the two nodes
            self.space.link(node1, node2)

            # Increment the edges counter
            self.edges_counter += 1

            if not self.directed:
                # Take track of the same edge again in case of an undirected graph
                self.space.link(node2, node1)

                # Increment the edges counter
                self.edges_counter += 1

            # Keep track of the edge weight
            if node2 not in self.space.space[node1].weights:
                self.space.space[node1].weights[node2] = set()

            if not self.directed:
                if node1 not in self.space.space[node2].weights:
                    self.space.space[node2].weights[node1] = set()

        self.space.space[node1].weights[node2].add(weight)

        if not self.directed:
            self.space.space[node2].weights[node1].add(weight)

        # Keep track of the edges here
        self.edges.add((node1, node2, weight))

    def _node_memory(self, node: str) -&gt; None:
        &#34;&#34;&#34;Build the node memory as a vector containing information about its neighbors.

        Parameters
        ----------
        node : str
            The node for which we want to build the memory.

        Raises
        ------
        Exception
            - if the input `node` is not in the graph space;
            - if the input `node` does not have any neighbors.
        &#34;&#34;&#34;

        if node not in self.space.space:
            raise Exception(f&#34;Node `{node}` is not in the graph space&#34;)

        neighbors = self.space.space[node].children

        node_memory = None

        for neighbor in neighbors:
            # Get the real weight from vector tags
            for weight in self.space.space[node].weights[neighbor]:
                # Retrieve the weight vector from the space
                weight_vector = self.space.space[f&#34;{WEIGHT_ID}{weight}&#34;]

                if node_memory is None:
                    # Initialize the node memory with the first neighbor
                    # multiplied by its weight vector
                    node_memory = weight_vector * self.space.space[neighbor]

                else:
                    # Multiply each neighbor with its weight vector and
                    # bundle all the resulting vectors together to build the node memory
                    node_memory = node_memory + (weight_vector * self.space.space[neighbor])

        # Store the node memory into the memory property of the node vector object
        self.space.space[node].memory = node_memory

    def _weight_memory(self) -&gt; None:
        &#34;&#34;&#34;Build the weights memory.
        &#34;&#34;&#34;

        # Recover edge weights from the space
        for node in self.space.space:
            # Check whether the current node is not the actual graph memory
            # Also, check whether the current node is not a weight vector
            if node != GRAPH_ID and not node.startswith(WEIGHT_ID):
                for neighbor in self.space.space[node].weights:
                    # Retrieve the weights on these edges
                    self.weights.update(self.space.space[node].weights[neighbor])

        for weight in self.weights:
            # Build a random vector
            weight_vector = Vector(name=f&#34;{WEIGHT_ID}{weight}&#34;, size=self.size, vtype=self.vtype)

            self.space.insert(weight_vector)

    @staticmethod
    def _error_rate(instance: &#34;GraphModel&#34;) -&gt; Tuple[float, Set[Tuple[str, str, float]], Set[Tuple[str, str, float]]]:
        &#34;&#34;&#34;Just a wrapper around the `error_rate` function to make it callable in multiprocessing.
        It is safe to run in multiprocessing because it does not modify any instance attributes.

        Parameters
        ----------
        instance : GraphModel
            A GraphModel instance.

        Returns
        -------
        tuple
            A tuple with the error rate, and the sets of flase positive and false negative edges
            among those in the input `edges`.
        &#34;&#34;&#34;

        return instance.error_rate()

    def error_rate(self) -&gt; Tuple[float, Set[Tuple[str, str, float]], Set[Tuple[str, str, float]]]:
        &#34;&#34;&#34;Compute the error rate defined as the number of mispredicted edges on the total number of edges.
        Note that the error rate depends on the set of edges in input to this function which could be different
        from the actual set of edges used to build the graph model.

        Returns
        -------
        tuple
            A tuple with the error rate, and the sets of flase positive and false negative edges
            among those in the input `edges`.
        &#34;&#34;&#34;

        # Compute the error rate as the number of mispredicted edges over the total number of edges
        false_negatives = set()

        for edge in self.edges:
            node1, node2, weight_true = edge

            # Compute node specific threshold
            node1_threshold = self.weight_to_node_specific_thresholds[weight_true].get(node1) if weight_true in self.weight_to_node_specific_thresholds else None

            # Search for the current edge
            edge_exists, _, dist_threshold = self.edge_exists(node1, node2, weight, threshold=node1_threshold)

            if weight_true not in self.weight_to_node_specific_thresholds:
                self.weight_to_node_specific_thresholds[weight_true] = dict()

            if node1 not in self.weight_to_node_specific_thresholds[weight_true]:
                self.weight_to_node_specific_thresholds[weight_true][node1] = dist_threshold

            if not edge_exists:
                # This is a false negative
                false_negatives.add(edge)

        return len(false_negatives) / len(edges), false_negatives

    def error_mitigation(
        self,
        max_iter: int=10,
        nproc: int=1
    ) -&gt; None:
        &#34;&#34;&#34;Mitigate the error rate of the graph model.

        Parameters
        ----------
        max_iter : int, deafult 10
            This is an iterative process that is repeated for up to `max_iter` iterations.
        nproc : int, default 1
            Maximum number of jobs for multiprocessing.
        &#34;&#34;&#34;

        if max_iter &gt; 0:
            # Keep track of misclassified edges
            false_negatives = set()

            # Split the set of edges into equally sized chunks
            # This is used for multiprocessing only
            chunk_size = len(self.edges) // nproc

            edges_list = None
            edges_subsets = None

            # Redefine the number of CPUs for multiprocessing
            if nproc &lt;= 1:
                nproc = 1

                # Compute the model error rate
                prev_error_rate, false_negatives = self.error_rate()

            else:
                if nproc &gt; mp.cpu_count():
                    nproc = mp.cpu_count()

                # Very inefficient but required
                edges_list = list(self.edges)

                edges_subsets = [(self, set(edges_list[i:i+chunk_size])) for i in range(0, len(edges_list), chunk_size)]

                with mp.Pool(processes=nproc) as pool:
                    # Compute the model error rate in multiprocessing
                    error_estimation = pool.starmap(self.__class__._error_rate, edges_subsets)

                    # Retrieve the set of misclassified edges
                    for _, false_negatives_partial in error_estimation:
                        false_negatives = false_negatives.union(false_negatives_partial)

                prev_error_rate = len(false_negatives) / len(self.edges)

            print(f&#34;(base)\tError rate: {prev_error_rate}\tFalse negatives: {len(false_negatives)}&#34;)

            # Error mitigate the model if the error rate is &gt; 0
            if prev_error_rate &gt; 0:
                for i in range(max_iter):
                    # Work on a copy of self here
                    graph = copy.deepcopy(self)

                    # Rebuild the mispredicted node memories
                    for edge in false_negatives:
                        #node1, node2, weight_true, weights_pred = edge
                        node1, node2, weight_true = edge

                        if graph.space.space[node1].memory:
                            # Retrieve the weight vector from the space
                            weight_true_vector = graph.space.space[f&#34;{WEIGHT_ID}{weight_true}&#34;]

                            # Defined correct connection vector
                            # Reinforcement signal
                            correct_connection = weight_true_vector * graph.space.space[node2]

                            if self.directed:
                                # Increase the signal of node1, node2 connection on weight_true
                                graph.space.space[GRAPH_ID] += graph.space.space[node1] * permute(correct_connection, rotate_by=1)

                            else:
                                # Do not permute the reinforced node1 memory if the global graph is not directed
                                graph.space.space[GRAPH_ID] += graph.space.space[node1] * correct_connection

                    # Reset `false_negatives`
                    false_negatives = set()

                    # Redefine the number of CPUs for multiprocessing
                    # There is no need to downscale nproc here
                    if nproc == 1:
                        # Compute the model error rate
                        error_rate, false_negatives = graph.error_rate()

                    else:
                        with mp.Pool(processes=nproc) as pool:
                            # Compute the model error rate in multiprocessing
                            error_estimation = pool.starmap(graph.__class__._error_rate, edges_subsets)

                            # Retrieve the set of misclassified edges
                            for _, false_negatives_partial in error_estimation:
                                false_negatives = false_negatives.union(false_negatives_partial)

                        error_rate = len(false_negatives) / len(graph.edges)

                    print(f&#34;(iter {i+1})\tError rate: {error_rate}\tFalse negatives: {len(false_negatives)}&#34;)

                    if error_rate &gt; prev_error_rate:
                        # Stop the error mitigating the graph model here
                        break

                    # Update the error rate
                    prev_error_rate = error_rate

                    # Make the error mitigated graph persistent
                    self.__dict__.update(graph.__dict__)

                    if error_rate == 0.0:
                        # There is nothing else to do here
                        break

    def fit(
        self,
        edges: Set[Tuple[str, str, Any]],
        build_nodes_memory: bool=True
    ) -&gt; None:
        &#34;&#34;&#34;Build the graph memory and store it into the space.

        Parameters
        ----------
        edges : set
            The set of edges defined as tuples `&lt;source, target, weight&gt;`.
        build_nodes_memory : bool, default True
            Build nodes and weight memories by default.
            This must be set to False in case this is invoked to mitigate the error rate.

        Raises
        ------
        ValueError
            If no edges are provided in input.
        &#34;&#34;&#34;

        if not edges:
            raise ValueError(&#34;Must provide at least one edge&#34;)

        for edge in edges:
            node1, node2, weight = edge

            self._add_edge(node1, node2, weight)

        if build_nodes_memory:
            # Build the vector representation of the edges weight
            self._weight_memory()

        graph = None

        for node in self.space.space:
            # Check whether the current node is not the actual graph memory
            # Also, check whether the current node is not a weight vector
            # This is required because this function can be run multiple times
            if node != GRAPH_ID and not node.startswith(WEIGHT_ID):
                if build_nodes_memory:
                    # Build the node memory
                    self._node_memory(node)

                if self.directed:
                    if graph is None:
                        if self.space.space[node].memory:
                            graph = self.space.space[node] * permute(self.space.space[node].memory, rotate_by=1)

                        else:
                            graph = self.space.space[node]

                    else:
                        if self.space.space[node].memory:
                            # Build the graph memory as the bundle of all the node memories rotated by 1 position
                            graph = graph + (self.space.space[node] * permute(self.space.space[node].memory, rotate_by=1))

                        else:
                            graph = graph + self.space.space[node]

                else:
                    if graph is None:
                        if self.space.space[node].memory:
                            graph = self.space.space[node] * self.space.space[node].memory

                        else:
                            graph = self.space.space[node]

                    else:
                        if self.space.space[node].memory:
                            # Build the graph memory as the bundle of all the node memories
                            graph = graph + (self.space.space[node] * self.space.space[node].memory)

                        else:
                            graph = graph + self.space.space[node]

        if not self.directed:
            # Introduce a factor 1/2 because if we expand the node memory, then
            # H(i)*H(j) and H(j)*H(i) will be counted twice
            graph.vector = graph.vector / 2

        # Check whether a graph is already present in the space
        if GRAPH_ID in self.space.space:
            self.space.remove(GRAPH_ID)

        # Rename the graph vector
        graph.name = GRAPH_ID

        # Store the graph vector into the space
        self.space.insert(graph)

        # Also keep track of the edges
        # This is used in case of the error_mitigation()
        self.edges = edges

    def edge_exists(
        self,
        node1: str,
        node2: str,
        weight: Any,
        threshold: Optional[float]=None
    ) -&gt; Tuple[bool, float, float]:
        &#34;&#34;&#34;Check whether an edge exists between `node1` and `node2` according to a specified distance `threshold`.

        node1 : str
            The source node name or ID.
        node2 : str
            The target node name or ID.
        weight : Any
            The edge weight.
        threshold : float, default None
            The distance threshold on vectors to establish the presence of the edge.
            It is automatically estimated if None.

        Returns
        -------
        Tuple
            True in case an edge between `node1` and `node2` exists in the graph space,
            otherwise False. It also returns the actual distance between the two vectors and
            the threshold used to establish whether the edge exists.

        Raises
        ------
        Exception
            - if there is no graph vector in the space;
            - if `node1` and `node2` are not in the graph space.
        &#34;&#34;&#34;

        if GRAPH_ID not in self.space.space:
            raise Exception(&#34;There is no graph in space&#34;)

        for node in [node1, node2]:
            if node not in self.space.space:
                raise Exception(f&#34;Node &#39;{node}&#39; not in space&#34;)

        if f&#34;{WEIGHT_ID}{weight}&#34; not in self.space.space:
            raise Exception(f&#34;Weight vector &#39;{weight}&#39; not in space&#34;)

        # Retrieve the vector representation of the graph
        graph = self.space.space[GRAPH_ID]

        # Also retrieve the vector representations of the two input nodes
        node1_vector = self.space.space[node1]
        node2_vector = self.space.space[node2]

        # Retrieve the node1 memory by binding the vector representation of
        # node1 with the vector representation of the graph
        # The resulting vector equals to the actual node1 memory plus noise
        node1_memory = bind(node1_vector, graph)

        if self.directed:
            # In case of directed graphs, nodes memory are rotated by 1 position
            # Thus, it must be rotated back in order to preserve the similarity
            node1_memory = permute(node1_memory, rotate_by=-1)

        # Check whether there is a edge between node1 and node2 by computing the distance between node2 and node1 memory
        # A distance close to 0 means the edge exists
        # A distance close to 1 means the edge does not exist
        # Retrieve the weight vector from the space
        weight_vector = self.space.space[f&#34;{WEIGHT_ID}{weight}&#34;]

        if threshold == None:
            if not self.space.space[node1].children:
                # We cannot do much if node1 has no children
                threshold = 1.0

            else:
                # Retrieve node1 children
                # There could be hundreds of thousands of nodes here, so we focus on the first 10
                neighbors = set(list(self.space.space[node1].children)[:10])

                # Pick the same number of random non-neighbors
                # This is very inefficient!
                non_neighbors = set(self.rand.choice(list(self.space.space.keys()), size=len(neighbors), replace=False))

                # Keep track of cosine distances between node1 and its neighbors plus random non-neighbors
                distances = list()

                for node in neighbors.union(non_neighbors):
                    if node == GRAPH_ID or node.startswith(WEIGHT_ID):
                        continue

                    # Retrieve the node vector from the space
                    # node is numpy.str_
                    node_vector = self.space.space[str(node)]

                    with np.errstate(invalid=&#34;ignore&#34;, divide=&#34;ignore&#34;):
                        distances.append((weight_vector * node_vector).dist(node1_memory, method=&#34;cosine&#34;))

                # Use the 5th percentile as threshold
                # This is a node-specific threshold for node1
                threshold = float(np.percentile(distances, 5))

        with np.errstate(invalid=&#34;ignore&#34;, divide=&#34;ignore&#34;):
            distance = (weight_vector * node2_vector).dist(node1_memory, method=&#34;cosine&#34;)

        if distance &lt; threshold:
            return True, distance, threshold

        return False, distance, threshold

    @staticmethod
    def _predict(
        instance: &#34;GraphModel&#34;,
        name: str,
        y_true: str,
        edges: Set[Tuple[str, str, Any]],
    ) -&gt; Tuple[float, Set[Tuple[str, str, float, Tuple[float]]], Set[Tuple[str, str, float, Tuple[float]]]]:
        &#34;&#34;&#34;Just a wrapper around the `predict` function to make it callable in multiprocessing.
        It is safe to run in multiprocessing because it does not modify any instance attributes.

        Parameters
        ----------
        instance : GraphModel
            A GraphModel instance.
        name : str
            The name associated to the set of edges.
        y_true : str
            The true class.
        edges : set
            The set of edges used to mitigate the graph model error rate.
            Note that the edges in this set do not necessarily have to be present in the graph.

        Returns
        -------
        tuple
            A tuple with the name of the test set, the true class, and a tuple with the predicted class and it&#39;s accuracy 
            in terms of percentage of edges that matched the predicted class.
        &#34;&#34;&#34;

        return name, y_true, instance.predict(edges)

    def predict(
        self,
        edges: Set[Tuple[str, str, Any]]
    ) -&gt; Tuple[Any, float]:
        &#34;&#34;&#34;Predict the weight (class) of a specific set of edges.

        Parameters
        ----------
        edges : set
            Set of edges.

        Returns
        -------
        tuple
            A tuple with the predicted class and it&#39;s accuracy in terms of percentage of edges
            that matched the predicted class.
        &#34;&#34;&#34;

        hits = {weight: 0 for weight in self.weights}

        for node1, node2, edge_weight in edges:
            if node1 in self.space.space and node2 in self.space.space:
                weight_pred = list()

                for weight in self.weights:
                    node1_threshold = self.weight_to_node_specific_thresholds[weight].get(node1) if weight in self.weight_to_node_specific_thresholds else None

                    _, weight_dist, dist_threshold = self.edge_exists(node1, node2, weight, threshold=node1_threshold)

                    weight_pred.append((weight, weight_dist))

                    if weight not in self.weight_to_node_specific_thresholds:
                        self.weight_to_node_specific_thresholds[weight] = dict()

                    if node1 not in self.weight_to_node_specific_thresholds[weight]:
                        self.weight_to_node_specific_thresholds[weight][node1] = dist_threshold

                if len(weight_pred) &gt; 1:
                    # Sort weights based on their distances
                    weight_pred = sorted(weight_pred, key=lambda w: w[1])

                    # Get the difference between the closest and the farthest distances
                    dist_diff = weight_pred[-1][1] - weight_pred[0][1]

                    # Use the difference in distances to select the top closest weights
                    weight_pred = [w[0] for w in weight_pred if w[1] - weight_pred[0][1] &lt; dist_diff]

                    for weight in weight_pred:
                        hits[weight] += 1

                else:
                    weight_pred = weight_pred[0][0]

                    hits[weight_pred] += 1

        # Get the best hit
        prediction = max(hits, key=hits.get)

        accuracy = (hits[prediction] / len(edges)) * 100.0

        return (prediction, accuracy)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="hdlib.model.graph.GraphModel.edge_exists"><code class="name flex">
<span>def <span class="ident">edge_exists</span></span>(<span>self, node1: str, node2: str, weight: Any, threshold: Optional[float] = None) ‑> Tuple[bool, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether an edge exists between <code>node1</code> and <code>node2</code> according to a specified distance <code>threshold</code>.</p>
<p>node1 : str
The source node name or ID.
node2 : str
The target node name or ID.
weight : Any
The edge weight.
threshold : float, default None
The distance threshold on vectors to establish the presence of the edge.
It is automatically estimated if None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple</code></dt>
<dd>True in case an edge between <code>node1</code> and <code>node2</code> exists in the graph space,
otherwise False. It also returns the actual distance between the two vectors and
the threshold used to establish whether the edge exists.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>
<ul>
<li>if there is no graph vector in the space;</li>
<li>if <code>node1</code> and <code>node2</code> are not in the graph space.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="hdlib.model.graph.GraphModel.error_mitigation"><code class="name flex">
<span>def <span class="ident">error_mitigation</span></span>(<span>self, max_iter: int = 10, nproc: int = 1) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Mitigate the error rate of the graph model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_iter</code></strong> :&ensp;<code>int, deafult 10</code></dt>
<dd>This is an iterative process that is repeated for up to <code>max_iter</code> iterations.</dd>
<dt><strong><code>nproc</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Maximum number of jobs for multiprocessing.</dd>
</dl></div>
</dd>
<dt id="hdlib.model.graph.GraphModel.error_rate"><code class="name flex">
<span>def <span class="ident">error_rate</span></span>(<span>self) ‑> Tuple[float, Set[Tuple[str, str, float]], Set[Tuple[str, str, float]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the error rate defined as the number of mispredicted edges on the total number of edges.
Note that the error rate depends on the set of edges in input to this function which could be different
from the actual set of edges used to build the graph model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple with the error rate, and the sets of flase positive and false negative edges
among those in the input <code>edges</code>.</dd>
</dl></div>
</dd>
<dt id="hdlib.model.graph.GraphModel.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, edges: Set[Tuple[str, str, Any]], build_nodes_memory: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Build the graph memory and store it into the space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>set</code></dt>
<dd>The set of edges defined as tuples <code>&lt;source, target, weight&gt;</code>.</dd>
<dt><strong><code>build_nodes_memory</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Build nodes and weight memories by default.
This must be set to False in case this is invoked to mitigate the error rate.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If no edges are provided in input.</dd>
</dl></div>
</dd>
<dt id="hdlib.model.graph.GraphModel.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, edges: Set[Tuple[str, str, Any]]) ‑> Tuple[Any, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Predict the weight (class) of a specific set of edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of edges.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple with the predicted class and it's accuracy in terms of percentage of edges
that matched the predicted class.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hdlib.model" href="index.html">hdlib.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hdlib.model.graph.GraphModel" href="#hdlib.model.graph.GraphModel">GraphModel</a></code></h4>
<ul class="">
<li><code><a title="hdlib.model.graph.GraphModel.edge_exists" href="#hdlib.model.graph.GraphModel.edge_exists">edge_exists</a></code></li>
<li><code><a title="hdlib.model.graph.GraphModel.error_mitigation" href="#hdlib.model.graph.GraphModel.error_mitigation">error_mitigation</a></code></li>
<li><code><a title="hdlib.model.graph.GraphModel.error_rate" href="#hdlib.model.graph.GraphModel.error_rate">error_rate</a></code></li>
<li><code><a title="hdlib.model.graph.GraphModel.fit" href="#hdlib.model.graph.GraphModel.fit">fit</a></code></li>
<li><code><a title="hdlib.model.graph.GraphModel.predict" href="#hdlib.model.graph.GraphModel.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Copyright &copy; 2025 Fabio Cumbo - Distributed under the <a href="https://github.com/cumbof/hdlib/blob/main/LICENSE" target="_blank">MIT License</a> - Documentation generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
